%
% Prologue for building troff width tables. The gsave/grestore pairs are
% for hardcopy.
%

/slowdown 25 def
/flagduplicates false def

/ascenderheight -1 def
/descenderdepth 0 def
/octalescapes 256 def
/startcomments 256 def
/currentfontdict null def
/scratchstring 512 string def

/Print {
	scratchstring cvs print flush
	slowdown {1 pop} repeat
} def

/ReEncode {	% vector fontname ReEncode -
	dup
	findfont dup length dict begin
		{1 index /FID ne {def}{pop pop} ifelse} forall
		/Encoding 3 -1 roll def
		currentdict
	end
	definefont pop
} bind def

/SelectFont {	% fontname SelectFont -
	findfont
		dup /PaintType get 0 eq {
			/scaling 1 def
			unitwidth resolution 72.0 div mul
		}{
			/scaling resolution 72 div def
			unitwidth
		} ifelse 
	scalefont
	/currentfontdict exch def
} def

/ChangeMetrics {DpostPrologue begin addmetrics end} def

/NamedInPrologue {
	dup
	DpostPrologue exch known {
		DpostPrologue exch get type /nametype eq {
			(named in prologue\n) Print
		} if
	}{pop} ifelse
} def

/SetAscender {
	/str exch def

	gsave
		currentfontdict setfont
		newpath
		0 0 moveto
		str false charpath flattenpath pathbbox
		/descenderdepth 4 -1 roll .5 mul def
		exch pop exch pop

		newpath
		0 0 moveto
		str 0 1 getinterval false charpath flattenpath pathbbox
		4 1 roll pop pop pop
		dup 3 1 roll sub .25 mul add
		/ascenderheight exch def
	grestore
} def

/GetAscender {
	ascenderheight descenderdepth ge {
		gsave
			currentfontdict setfont
			newpath
			0 0 moveto
			( ) dup 0 4 -1 roll put
			false charpath flattenpath pathbbox
			exch pop 3 -1 roll pop
			ascenderheight gt {2}{0} ifelse
			exch descenderdepth lt {1}{0} ifelse
			or
		grestore
	}{0} ifelse
} def

/GetWidth {
	gsave
		currentfontdict setfont
		( ) dup 0 4 -1 roll put
		stringwidth pop scaling mul round cvi
	grestore
} def

/GetCode {
	256 3 1 roll		% last unprintable match
	0 3 -1 roll {
		2 index eq {
			dup 127 and 32 ge {exit} if
			3 -1 roll pop
			dup 3 1 roll
		} if
		1 add
	} forall
	exch pop
	dup 255 gt {pop}{exch pop} ifelse
} def

% create a font with the given encoding array
/TMPFont {
	dup length dict begin
		{ 1 index /FID ne {def} {pop pop} ifelse } forall
		/Encoding exch def
		currentdict
	end
	/tmp-font exch definefont
} bind def

% print troff font glyph table for the given glyphs
%
% This function assumes "charset" global array contains troff
% character names (even entries) and PS font names (odd entries);
% see the list in StandardCharset function in shell.lib of devutf
% for an example.  From this array, this function generates troff
% font tables in three steps:
%
% 1. Initialize chcodes array to contain the position of charset characters
%    in the encoding array of the current font (256 for characters not present)
% 2. Generate a temporary font encoding array for the characters in charset
%   (for finding the width of characters)
% 3. Create a temporary font with this new encoding array
% 4. Print troff table columns for each character in charset array
/BuildFontCharset256 {
	% create the charcode array
	/chcodes charset length 2 idiv array def
	0 2 charset length 2 sub {
		/i exch def
		/key charset i get def
		/val charset i 1 add get def
		/chcode currentfontdict /Encoding get val GetCode def
		chcodes i 2 idiv chcode put
	} for
	% create a temporary array for charset
	/tmpenc charset length array def
	0 2 charset length 2 sub {
		/i exch def
		/val charset i 1 add get def
		val type /stringtype eq not {
			tmpenc i 2 idiv val put
		} if
	} for

	% use the new font
	/prevfontdict currentfontdict def
	/currentfontdict tmpenc currentfontdict TMPFont def
	currentfontdict setfont
	/lastvalid 0 def		% last character was valid if 1

	% print troff table
	0 2 charset length 2 sub {
		/i exch def
		/key charset i get def
		/val charset i 1 add get def
		/curcode i 2 idiv def		% tmpenc chcode
		/chcode chcodes curcode get def	% original chcode
		val type /stringtype eq {
			lastvalid 1 eq {
				key Print
				(\t) Print val Print
				(\n) Print
			} if
		}{
			% output only available glyphs
			currentfontdict /CharStrings get val known {
				chcode octalescapes ge key (---) eq and {
					(\\0) Print chcode 8 (   ) cvrs Print
				}{
					key Print
				} ifelse
				(\t) Print curcode GetWidth Print
				(\t) Print curcode GetAscender Print
				chcode startcomments lt {
					(\t) Print chcode Print
				} {
					(\t) Print val Print
				} ifelse
				(\n) Print
				/lastvalid 1 def
			}{
				/lastvalid 0 def
			} ifelse
		} ifelse
	} for
	% restore the original font
	/currentfontdict prevfontdict def
} def

% call BuildFontCharset256 for charsets of at most 256 characters
%
% BuildFontCharset256 assumes the charset array contains at most
% 256 characters.  This function splits the charset array
% otherwise and calls BuildFontCharset256 multiple times.
/BuildFontCharset {
	/charset2 charset def
	0 512 charset2 length {
		/i exch def
		/len charset2 length i 512 add le { charset2 length i sub } {512} ifelse def
		/charset charset2 i len getinterval def
		BuildFontCharset256
	} for
	/charset charset2 def
} def

/BuildDescCharset {
	/DescDict 512 dict def
	/Characters 0 def

	0 1 charset length 1 sub {
		/i exch def
		/key charset i get def

		key length 2 eq {
			DescDict key cvn known {
				flagduplicates {	% for debugging
					(<<<duplicated character: ) Print
					key Print
					(>>>\n) Print
				} if
			}{
				DescDict key cvn 1 put
				key Print
				/Characters Characters 1 add def
				Characters 20 mod 0 eq {(\n)}{( )} ifelse Print
			} ifelse
		} if
	} for
} def

